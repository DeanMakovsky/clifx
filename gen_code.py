"""This file generates c++ code for each light/device message.
// same thing, different type number
"""


messages = [
#  (className, hasPayload, protocol number)
	("GetService", False, 2),
	("StateService", True, 3),
	("GetHostInfo" , False, 2),
	("StateHostInfo" , True, 3),
	("GetHostFirmware" , False, 4),
	("StateHostFirmware" , True, 5),
	("GetWifiInfo", False, 16),
	("StateWifiInfo", True, 17),
	("GetWifiFirmware", False, 18),
	("StateWifiFirmware", True, 19),
	("GetPower", False, 20),
	("SetPower", True, 21),
	("StatePower", True, 22),
	("GetLabel", False, 23),
	("SetLabel", True, 24),
	("StateLabel", True, 25),
	("GetVersion", False, 32),
	("StateVersion", True, 33),
	("GetInfo", False, 34),
	("StateInfo", True, 35),
	("Acknowledgement", False, 45),  # check if it has payload, I don't think it does
	("GetLocation", False, 48),
	("StateLocation", True, 50),
	("GetGroup", False, 51),
	("StateGroup", True, 53),
	("EchoRequest", True, 58),
	("EchoResponse", True, 59),


	("Get", False, 101),
	("SetColor", True, 102),
	("State", True, 107),
	("GetPower_Light", False, 116),  # same as above  # TODO check that these have the same content too
	("SetPower_Light", True, 117),  # different from above
	("StatePower_Light", True, 118)  # same as StatePower_Device

]

def listPayloadMessages():
	"""For help generating the 'variables' dictionary"""
	for i in messages:
		if i[1]:
			print "'" + i[0] + "' : [],"

	import sys
	sys.exit(0)


bits_to_name = {
	8:  'uint8_t ',
	16: 'uint16_t',
	"16+":'short   ',
	32: 'uint32_t',
	64: 'uint64_t'
}

(16, 'hue'),(16, 'saturation'),(16, 'brightness'),(16, 'kelvin')

variables = {
	'StateService' : [(8, "service"), (32, "port")],
	'StateHostInfo' : [('float   ', 'signal') , (32, 'tx') , (32, 'rx'), ('16+', 'reserved')],
	'StateHostFirmware' : [(64, 'build'), (64, 'reserved'), (32, 'version')],
	'StateWifiInfo' : [('float   ', 'signal'), (32, 'tx') , (32, 'rx'), ('16+', 'reserved')],
	'StateWifiFirmware' : [(64, 'build'), (64, 'reserved'), (32, 'version')],
	'SetPower' : [(16, 'level')],
	'StatePower' : [(16, 'level')],
	'SetLabel' : [],  # TODO this and next are strings, 32 bytes
	'StateLabel' : [],
	'StateVersion' : [(32, 'vendor'), (32, 'product'), (32, 'version')],
	'StateInfo' : [(64, 'time'), (64, 'uptime') , (64, 'downtime')],
	'StateLocation' : [],  # TODO
	'StateGroup' : [], 
	'EchoRequest' : [('char', 'payload[64]')],
	'EchoResponse' : [('char', 'payload[64]')],
	'SetColor' : [(8, 'reserved'), (16, 'hue'),(16, 'saturation'),(16, 'brightness'),(16, 'kelvin'), (32, 'duration')],
	'State' : [(16, 'hue'),(16, 'saturation'),(16, 'brightness'),(16, 'kelvin'), ("16+", 'reserved'), (16, 'power'), ('char', 'label[32]'), (64, 'reserved')],
	'SetPower_Light' : [(16, 'level'), (32, 'duration')],
	'StatePower_Light' : [(16, 'level')]
}

def convertType(thing):
	if thing in bits_to_name:
		return bits_to_name[thing]
	return thing
	
def makeParams(className, insertUnderscoreNames=False):
	"""To be used in header definition (False) and class implementation (True)"""
	var_list = variables[className]
	if len(var_list) == 0:
		return ""
	
	def operate(a_var):
		temp = False
		if a_var[1] != "reserved":
			type_name = convertType(a_var[0]).strip()
			temp = type_name
			if insertUnderscoreNames:
				temp += " _" + a_var[1]
		return temp

	# get first word
	i = 0
	while i < len(var_list):
		ret = operate(var_list[i])
		i += 1
		if ret == False:
			pass
		else:
			break
	# get the rest of the params, separated by commas
	while i < len(var_list):
		temp = operate(var_list[i])
		i += 1
		if temp != False:
			ret += ", " + temp
	return ret

# print makeParams("SetColor", False)
# print "~~~~~~"
# print makeParams("SetColor", True)
# import sys
# sys.exit(0)

def appendWarning(file_var):
	file_var.write("// Stop!  Do not modify this file as it was auto-generated by " + __file__ + "\n\n")

def addThisToThat(srcPath, file_var):
	with open(srcPath, 'r') as src:
		for i in src:
			file_var.write(i)

with open("Messages.h", "w") as headfile:
	with open("Messages.cpp", "w") as bodyfile:
		
		appendWarning(headfile)
		appendWarning(bodyfile)

		addThisToThat("static_files/head_start.h", headfile)
		addThisToThat("static_files/body_start.cpp", bodyfile)

		for message_spec in messages:
			# first do header (.h) file
			className = message_spec[0]
			headfile.write("class %s: public Header {\n" % className)
			if message_spec[1]:  # has payload
				headfile.write( "\tstruct {\n" )
				for extra in variables[className]:
					var_name = extra[1]
					# if not used, then make the variable look like "uint8_t :8;"
					if var_name == "reserved":  
						var_name = extra[0]
						if var_name == "16+":
							var_name = 16
						var_name = ":" + str(var_name)
					headfile.write(	"\t\t" + convertType(extra[0]) + " " + var_name + ";\n")  # TODO optional :len
				headfile.write( "\t} payload;\n" )

				headfile.write( "public:\n")
				headfile.write( "\t%s(%s);\n" % (className, makeParams(className) ) ) # TODO add params
				headfile.write( "\t%s(char *);\n" % className )

				headfile.write( "\tMessageBuffer * makeBuffer();\n")
				headfile.write( "\tvoid printEverything();\n" )
			else:
				headfile.write( "public:\n")
				headfile.write( "\t%s();\n" % (className) ) # TODO add params
				headfile.write( "\t%s(char *);\n" % className )
			# 

			headfile.write( "};\n\n\n" )
			


			# now do code (.cpp) file

			if message_spec[1]:  # has payload
				# parameter constructor
				bodyfile.write("%s::%s(%s) {\n" % (className, className, makeParams(className, True)) )
				bodyfile.write("\thead.type = %d;\n" % message_spec[2] )
				bodyfile.write("\thead.size = sizeof(head) + sizeof(payload);\n")
				bodyfile.write("\tmemset(&payload, 0, sizeof(payload));\n")
				var_list = variables[className]
				for a_var in var_list:
					if a_var[1] != "reserved":
						bodyfile.write("\tpayload.%s = _%s;\n" % (a_var[1], a_var[1]) )
				bodyfile.write("}\n\n")
				# deserialize
				bodyfile.write("%s::%s(char * buf) : Header(buf) {\n" % (className, className) )
				bodyfile.write("\tmemcpy(&payload, buf + sizeof(head), sizeof(payload));\n")
				bodyfile.write("}\n\n")
				# sending code
				bodyfile.write("MessageBuffer * %s::makeBuffer() {\n" % className)
				bodyfile.write("\tchar buf[ sizeof(head) + sizeof(payload)];\n")
				bodyfile.write("\tint size = sizeof(head) + sizeof(payload);\n")
				bodyfile.write("\tmemcpy(buf, &head, sizeof(head));\n")
				bodyfile.write("\tmemcpy(buf + sizeof(head), &payload, sizeof(payload));\n")
				bodyfile.write("\tMessageBuffer * mb = new MessageBuffer(buf, size);\n")
				bodyfile.write("\treturn mb;\n")
				bodyfile.write("}\n\n")
				# debug code
				bodyfile.write('void %s::printEverything() {\n' % className)
				bodyfile.write('\tHeader::printEverything();\n')
				bodyfile.write('\tcout << "~~~~~~ Payload ~~~~~~" << endl;\n')
				for a_var in var_list:
					if a_var[1] != "reserved":
						bodyfile.write("\tcout << fcol << \"%s\" << tab << payload.%s << endl;\n" % (a_var[1], a_var[1]) )
					else:
						bodyfile.write("\tcout << fcol << \"%s\" << tab << \"%s bits\" << endl;\n" % (a_var[1], str(a_var[0])) )
				bodyfile.write("}\n\n\n")

			else:  # no payload
				# default constructor
				bodyfile.write("%s::%s() {\n" % (className, className) )
				bodyfile.write("\thead.type = %d;\n" % message_spec[2] )
				bodyfile.write("}\n\n")
				# deserialize
				bodyfile.write("%s::%s(char * buf) : Header(buf) {\n" % (className, className) )
				bodyfile.write("}\n\n\n")
		addThisToThat("static_files/head_end.h", headfile)
