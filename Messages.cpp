// Stop!  Do not modify this file as it was auto-generated by gen_code.py

#include <iostream>
#include <string>
#include <iomanip> // for cout columns
#include <bitset>  // for pretty printing odd-sized bit fields

#include <cstring>
#include <cstdio>

#include <arpa/inet.h>  // for inet_pton
#include <sys/socket.h>
#include <netinet/in.h>

#include "Messages.h"

// #define tab "\t"
#define fcol setw(15)
#define tab setw(10)

using namespace std;


MessageBuffer::MessageBuffer(char * _buf, int _size) {
	buf = (char *) malloc(_size);
	size = _size;
	memcpy(buf, _buf, size);
}
MessageBuffer::~MessageBuffer() {
	free(buf);
}


Header::Header() {
	// cout << "Header size (this): " << sizeof(*this) << endl;
	// cout << "Header size (Header): " << sizeof(Header) << endl;
	// cout << "Header size (Color): " << sizeof(Color) << endl;

	// zero out header
	memset(&head, 0, sizeof(head));
	head.size = sizeof(head);
	head.protocol = 1024;
	head.tagged = 1;
	head.addressable = 1;
	head.source = 0;

	// h.target = 0; // for all MACs
	head.sequence = 0;

	head.type = 2; // TODO this is only sometimes correct

}

/**
* Assumes buffer has enough good data for sizeof(Header.head)
*/
Header::Header(char * buffer) {
	memcpy(&head, buffer, sizeof(head) );
}

int Header::getType() {
	return head.type;
}

/**
* Reads from a socket the appropriate number of bytes and puts it into a new object.
* If the message type is unknown (or payload is empty), returns a regular Header.
* TODO socket will be non-blocking, so if there is no data, then "type" will be 0.
*/
Header Header::deserialize(int sockfd) {
	
	// set up data structures
	char buffer[100];
	memset(buffer, 0, sizeof(buffer));

	struct sockaddr_in sender;
	socklen_t senderSize = sizeof(sender);
	socklen_t backup = senderSize;


	// get data from socket
	int ret = recvfrom(sockfd, buffer, sizeof(buffer), 0 ,
		(sockaddr *) &sender, &senderSize);
	if (ret == -1) {
		int val = errno;
		if (val == EAGAIN || val == EWOULDBLOCK) {
			// printf("No data to read.\n");
			Header h;
			h.head.type = 0;
			return h;
		}
		printf("Error reading from socket: %d, %s\n", val, strerror(val) );
	}


	// sender diagnostics, mainly for fun
	if (backup != senderSize) {
		printf("The sender address of this message changed (%d -> %d)\n", backup, senderSize);
	}
	// printf("sin_family: %hd\t", sender.sin_family);
	// printf("AF_INET := %d\n", AF_INET);
	char ip_buffer[100];
	memset(ip_buffer, 0, sizeof(ip_buffer));
	inet_ntop(AF_INET, &sender.sin_addr.s_addr, ip_buffer, sizeof(ip_buffer));
	printf("Sending address: %s:%hu\n", ip_buffer, ntohs(sender.sin_port));


	// validate the input some
	printf("Read -%d- bytes.\n", ret);
	if (ret > sizeof(buffer)) {
		printf("Read too many bytes for buffer, truncating message.\n");
		ret = sizeof(buffer);
	}
	if (ret < sizeof(Header::head)) {
		printf("Not enough bytes to fill a Header object.\n");
	}

	// make and return new object
	Header h(buffer);
	if (h.head.protocol != 1024) {
		printf("Incorrect protocol number, probably bad packet.\n");
	}
	// printf("Size: %d\nProtocol: %d\nType: %d\n", h.size, h.protocol, h.type);
	// h.printEverything();




	// TODO make a map of message types to classes and instantiate the proper class right here.




	return h;
}

MessageBuffer * Header::makeBuffer() {
	char buf[sizeof(Header::head)];
	int size = sizeof(head);
	memcpy(buf, &head, sizeof(head));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void Header::printEverything() {
	cout << "~~~~~~~ Frame ~~~~~~~" << endl;
	cout << fcol << "size" << tab << head.size << endl;
	cout << fcol << "protocol" << tab << head.protocol << endl;
	cout << fcol << "addressable" << tab << bitset<1>(head.addressable) << endl;
	cout << fcol << "tagged" << tab << bitset<1>(head.tagged) << endl;
	cout << fcol << "origin" << tab << bitset<2>(head.origin) << endl;
	cout << fcol << "source" << tab << head.source << endl;
	cout << "~~~~~ Frame Address ~~~~~" << endl;
	cout << fcol << "target" << tab << "0x" << flush;
	char buf[8];
	memcpy(buf, &(head.target), 8);
	for (int i = 0; i < 8; i++) {
		printf("%2hhx", buf[i]);
	}
	printf("\n");
	cout << fcol << "reserved" << tab << "6 bytes" << endl;
	cout << fcol << "res_required" << tab << bitset<1>(head.res_required) << endl;
	cout << fcol << "ack_required" << tab << bitset<1>(head.ack_required) << endl;
	cout << fcol << "reserved" << tab << "6 bits" << endl;
	cout << fcol << "sequence" << tab << bitset<8>(head.sequence).to_ulong() << endl;
	cout << "~~~~~ Protocol Header ~~~~~" << endl;
	cout << fcol << "reserved" << tab << "8 bytes" << endl;
	cout << fcol << "type" << tab << head.type << endl;
	cout << fcol << "reserved" << tab << "2 bytes" << endl;
}

/*


Color::Color(unsigned int _hue, unsigned int _sat, unsigned int _bright, unsigned int _kelvin, unsigned int _duration) : Header() {
	// cout << "Color size (this): " << sizeof(*this) << endl;
	// cout << "Color size (Header): " << sizeof(Header) << endl;
	// cout << "Color size (Color): " << sizeof(Color) << endl;
	head.size = sizeof(head) + sizeof(payload);

	// zero out payload
	memset(&payload, 0, sizeof(payload));
	payload.hue = _hue;
	payload.saturation = _sat;
	payload.brightness = _bright;
	payload.kelvin = _kelvin;
	payload.duration = _duration;

	head.type = 102; // color message

}

MessageBuffer * Color::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void Color::printEverything() {
	Header::printEverything();
	cout << "~~~~~ Protocol Header ~~~~~" << endl;
	cout << fcol << "reserved" << tab << "1 byte" << endl;
	cout << fcol << "hue" << tab << payload.hue << endl;
	cout << fcol << "saturation" << tab << payload.saturation << endl;
	cout << fcol << "brightness" << tab << payload.brightness << endl;
	cout << fcol << "kelvin" << tab << payload.kelvin << endl;
	cout << fcol << "duration" << tab << payload.duration << endl;
}


// ~~~model for generating code:


GetWifiInfo::GetWifiInfo() {
	head.type = 123123;
}

GetWifiInfo::GetWifiInfo(char * buf) : Header(buf) {
}



StateWifiInfo::StateWifiInfo(float _a,uint32_t _b,uint32_t _c) {
	head.type = 234213432;
	payload.a = _a;
	payload.b = _b;
	payloda.c = _c;
}

StateWifiInfo::StateWifiInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateWifiInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateWifiInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~ Payload ~~~~~" << endl;
	cout << fcol << "reserved" << tab << "1 byte" << endl;
	// ...
}
*/GetService::GetService() {
	head.type = 2;
}

GetService::GetService(char * buf) : Header(buf) {
}


StateService::StateService(uint8_t _service, uint32_t _port) {
	head.type = 3;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.service = _service;
	payload.port = _port;
}

StateService::StateService(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateService::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateService::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "service" << tab << payload.service << endl;
	cout << fcol << "port" << tab << payload.port << endl;
}


GetHostInfo::GetHostInfo() {
	head.type = 2;
}

GetHostInfo::GetHostInfo(char * buf) : Header(buf) {
}


StateHostInfo::StateHostInfo(float _signal, uint32_t _tx, uint32_t _rx) {
	head.type = 3;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.signal = _signal;
	payload.tx = _tx;
	payload.rx = _rx;
}

StateHostInfo::StateHostInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateHostInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateHostInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "signal" << tab << payload.signal << endl;
	cout << fcol << "tx" << tab << payload.tx << endl;
	cout << fcol << "rx" << tab << payload.rx << endl;
	cout << fcol << "reserved" << tab << "16+ bits" << endl;
}


GetHostFirmware::GetHostFirmware() {
	head.type = 4;
}

GetHostFirmware::GetHostFirmware(char * buf) : Header(buf) {
}


StateHostFirmware::StateHostFirmware(uint64_t _build, uint32_t _version) {
	head.type = 5;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.build = _build;
	payload.version = _version;
}

StateHostFirmware::StateHostFirmware(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateHostFirmware::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateHostFirmware::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "build" << tab << payload.build << endl;
	cout << fcol << "reserved" << tab << "64 bits" << endl;
	cout << fcol << "version" << tab << payload.version << endl;
}


GetWifiInfo::GetWifiInfo() {
	head.type = 16;
}

GetWifiInfo::GetWifiInfo(char * buf) : Header(buf) {
}


StateWifiInfo::StateWifiInfo(float _signal, uint32_t _tx, uint32_t _rx) {
	head.type = 17;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.signal = _signal;
	payload.tx = _tx;
	payload.rx = _rx;
}

StateWifiInfo::StateWifiInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateWifiInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateWifiInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "signal" << tab << payload.signal << endl;
	cout << fcol << "tx" << tab << payload.tx << endl;
	cout << fcol << "rx" << tab << payload.rx << endl;
	cout << fcol << "reserved" << tab << "16+ bits" << endl;
}


GetWifiFirmware::GetWifiFirmware() {
	head.type = 18;
}

GetWifiFirmware::GetWifiFirmware(char * buf) : Header(buf) {
}


StateWifiFirmware::StateWifiFirmware(uint64_t _build, uint32_t _version) {
	head.type = 19;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.build = _build;
	payload.version = _version;
}

StateWifiFirmware::StateWifiFirmware(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateWifiFirmware::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateWifiFirmware::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "build" << tab << payload.build << endl;
	cout << fcol << "reserved" << tab << "64 bits" << endl;
	cout << fcol << "version" << tab << payload.version << endl;
}


GetPower::GetPower() {
	head.type = 20;
}

GetPower::GetPower(char * buf) : Header(buf) {
}


SetPower::SetPower(uint16_t _level) {
	head.type = 21;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
}

SetPower::SetPower(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetPower::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetPower::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
}


StatePower::StatePower(uint16_t _level) {
	head.type = 22;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
}

StatePower::StatePower(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StatePower::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StatePower::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
}


GetLabel::GetLabel() {
	head.type = 23;
}

GetLabel::GetLabel(char * buf) : Header(buf) {
}


SetLabel::SetLabel(string _payload) {
	head.type = 24;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

SetLabel::SetLabel(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetLabel::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetLabel::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[32]" << tab << payload.payload[32] << endl;
}


StateLabel::StateLabel(string _payload) {
	head.type = 25;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

StateLabel::StateLabel(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateLabel::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateLabel::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[32]" << tab << payload.payload[32] << endl;
}


GetVersion::GetVersion() {
	head.type = 32;
}

GetVersion::GetVersion(char * buf) : Header(buf) {
}


StateVersion::StateVersion(uint32_t _vendor, uint32_t _product, uint32_t _version) {
	head.type = 33;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.vendor = _vendor;
	payload.product = _product;
	payload.version = _version;
}

StateVersion::StateVersion(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateVersion::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateVersion::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "vendor" << tab << payload.vendor << endl;
	cout << fcol << "product" << tab << payload.product << endl;
	cout << fcol << "version" << tab << payload.version << endl;
}


GetInfo::GetInfo() {
	head.type = 34;
}

GetInfo::GetInfo(char * buf) : Header(buf) {
}


StateInfo::StateInfo(uint64_t _time, uint64_t _uptime, uint64_t _downtime) {
	head.type = 35;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.time = _time;
	payload.uptime = _uptime;
	payload.downtime = _downtime;
}

StateInfo::StateInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "time" << tab << payload.time << endl;
	cout << fcol << "uptime" << tab << payload.uptime << endl;
	cout << fcol << "downtime" << tab << payload.downtime << endl;
}


Acknowledgement::Acknowledgement() {
	head.type = 45;
}

Acknowledgement::Acknowledgement(char * buf) : Header(buf) {
}


GetLocation::GetLocation() {
	head.type = 48;
}

GetLocation::GetLocation(char * buf) : Header(buf) {
}


StateLocation::StateLocation(string _location, string _label, uint64_t _updated_at) {
	head.type = 50;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.location, _location.c_str(), _location.size());
	memcpy(&payload.label, _label.c_str(), _label.size());
	payload.updated_at = _updated_at;
}

StateLocation::StateLocation(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateLocation::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateLocation::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "location[16]" << tab << payload.location[16] << endl;
	cout << fcol << "label[32]" << tab << payload.label[32] << endl;
	cout << fcol << "updated_at" << tab << payload.updated_at << endl;
}


GetGroup::GetGroup() {
	head.type = 51;
}

GetGroup::GetGroup(char * buf) : Header(buf) {
}


StateGroup::StateGroup(string _location, string _label, uint64_t _updated_at) {
	head.type = 53;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.location, _location.c_str(), _location.size());
	memcpy(&payload.label, _label.c_str(), _label.size());
	payload.updated_at = _updated_at;
}

StateGroup::StateGroup(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateGroup::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateGroup::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "location[16]" << tab << payload.location[16] << endl;
	cout << fcol << "label[32]" << tab << payload.label[32] << endl;
	cout << fcol << "updated_at" << tab << payload.updated_at << endl;
}


EchoRequest::EchoRequest(string _payload) {
	head.type = 58;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

EchoRequest::EchoRequest(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * EchoRequest::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void EchoRequest::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[64]" << tab << payload.payload[64] << endl;
}


EchoResponse::EchoResponse(string _payload) {
	head.type = 59;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

EchoResponse::EchoResponse(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * EchoResponse::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void EchoResponse::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[64]" << tab << payload.payload[64] << endl;
}


Get::Get() {
	head.type = 101;
}

Get::Get(char * buf) : Header(buf) {
}


SetColor::SetColor(uint16_t _hue, uint16_t _saturation, uint16_t _brightness, uint16_t _kelvin, uint32_t _duration) {
	head.type = 102;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.hue = _hue;
	payload.saturation = _saturation;
	payload.brightness = _brightness;
	payload.kelvin = _kelvin;
	payload.duration = _duration;
}

SetColor::SetColor(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetColor::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetColor::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "reserved" << tab << "8 bits" << endl;
	cout << fcol << "hue" << tab << payload.hue << endl;
	cout << fcol << "saturation" << tab << payload.saturation << endl;
	cout << fcol << "brightness" << tab << payload.brightness << endl;
	cout << fcol << "kelvin" << tab << payload.kelvin << endl;
	cout << fcol << "duration" << tab << payload.duration << endl;
}


State::State(uint16_t _hue, uint16_t _saturation, uint16_t _brightness, uint16_t _kelvin, uint16_t _power, string _label) {
	head.type = 107;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.hue = _hue;
	payload.saturation = _saturation;
	payload.brightness = _brightness;
	payload.kelvin = _kelvin;
	payload.power = _power;
	memcpy(&payload.label, _label.c_str(), _label.size());
}

State::State(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * State::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void State::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "hue" << tab << payload.hue << endl;
	cout << fcol << "saturation" << tab << payload.saturation << endl;
	cout << fcol << "brightness" << tab << payload.brightness << endl;
	cout << fcol << "kelvin" << tab << payload.kelvin << endl;
	cout << fcol << "reserved" << tab << "16+ bits" << endl;
	cout << fcol << "power" << tab << payload.power << endl;
	cout << fcol << "label[32]" << tab << payload.label[32] << endl;
	cout << fcol << "reserved" << tab << "64 bits" << endl;
}


GetPower_Light::GetPower_Light() {
	head.type = 116;
}

GetPower_Light::GetPower_Light(char * buf) : Header(buf) {
}


SetPower_Light::SetPower_Light(uint16_t _level, uint32_t _duration) {
	head.type = 117;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
	payload.duration = _duration;
}

SetPower_Light::SetPower_Light(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetPower_Light::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetPower_Light::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
	cout << fcol << "duration" << tab << payload.duration << endl;
}


StatePower_Light::StatePower_Light(uint16_t _level) {
	head.type = 118;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
}

StatePower_Light::StatePower_Light(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StatePower_Light::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StatePower_Light::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
}


