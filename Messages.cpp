// Stop!  Do not modify this file as it was auto-generated by gen_code.py

#include <iostream>
#include <string>
#include <iomanip> // for cout columns
#include <bitset>  // for pretty printing odd-sized bit fields
#include <map>

#include <cstring>
#include <cstdio>

#include <arpa/inet.h>  // for inet_pton
#include <sys/socket.h>
#include <netinet/in.h>

#include "Messages.h"

// #define tab "\t"
#define fcol setw(15)
#define tab setw(10)

using namespace std;


map<int, Header *(*)(char *)> mapMaker() {
	map<int, Header *(*)(char *)> typeToCon;
	typeToCon[2] = (Header *(*)(char *)) GetServiceFac;
	typeToCon[3] = (Header *(*)(char *)) StateServiceFac;
	typeToCon[2] = (Header *(*)(char *)) GetHostInfoFac;
	typeToCon[3] = (Header *(*)(char *)) StateHostInfoFac;
	typeToCon[4] = (Header *(*)(char *)) GetHostFirmwareFac;
	typeToCon[5] = (Header *(*)(char *)) StateHostFirmwareFac;
	typeToCon[16] = (Header *(*)(char *)) GetWifiInfoFac;
	typeToCon[17] = (Header *(*)(char *)) StateWifiInfoFac;
	typeToCon[18] = (Header *(*)(char *)) GetWifiFirmwareFac;
	typeToCon[19] = (Header *(*)(char *)) StateWifiFirmwareFac;
	typeToCon[20] = (Header *(*)(char *)) GetPowerFac;
	typeToCon[21] = (Header *(*)(char *)) SetPowerFac;
	typeToCon[22] = (Header *(*)(char *)) StatePowerFac;
	typeToCon[23] = (Header *(*)(char *)) GetLabelFac;
	typeToCon[24] = (Header *(*)(char *)) SetLabelFac;
	typeToCon[25] = (Header *(*)(char *)) StateLabelFac;
	typeToCon[32] = (Header *(*)(char *)) GetVersionFac;
	typeToCon[33] = (Header *(*)(char *)) StateVersionFac;
	typeToCon[34] = (Header *(*)(char *)) GetInfoFac;
	typeToCon[35] = (Header *(*)(char *)) StateInfoFac;
	typeToCon[45] = (Header *(*)(char *)) AcknowledgementFac;
	typeToCon[48] = (Header *(*)(char *)) GetLocationFac;
	typeToCon[50] = (Header *(*)(char *)) StateLocationFac;
	typeToCon[51] = (Header *(*)(char *)) GetGroupFac;
	typeToCon[53] = (Header *(*)(char *)) StateGroupFac;
	typeToCon[58] = (Header *(*)(char *)) EchoRequestFac;
	typeToCon[59] = (Header *(*)(char *)) EchoResponseFac;
	typeToCon[101] = (Header *(*)(char *)) GetFac;
	typeToCon[102] = (Header *(*)(char *)) SetColorFac;
	typeToCon[107] = (Header *(*)(char *)) StateFac;
	typeToCon[116] = (Header *(*)(char *)) GetPower_LightFac;
	typeToCon[117] = (Header *(*)(char *)) SetPower_LightFac;
	typeToCon[118] = (Header *(*)(char *)) StatePower_LightFac;
	return typeToCon;
}

map<int, Header *(*)(char *)> typeToCon = mapMaker();


MessageBuffer::MessageBuffer(char * _buf, int _size) {
	buf = (char *) malloc(_size);
	size = _size;
	memcpy(buf, _buf, size);
}
MessageBuffer::~MessageBuffer() {
	free(buf);
}


Header::Header() {
	// cout << "Header size (this): " << sizeof(*this) << endl;
	// cout << "Header size (Header): " << sizeof(Header) << endl;
	// cout << "Header size (Color): " << sizeof(Color) << endl;

	// zero out header
	memset(&head, 0, sizeof(head));
	head.size = sizeof(head);
	head.protocol = 1024;
	head.tagged = 1;
	head.addressable = 1;
	head.source = 0;

	// h.target = 0; // for all MACs
	head.sequence = 0;

}

/**
* Assumes buffer has enough good data for sizeof(Header.head)
*/
Header::Header(char * buffer) {
	memcpy(&head, buffer, sizeof(head) );
}

Header::~Header() {
}

int Header::getType() {
	return head.type;
}

void Header::setTarget(string tar) {
	head.tagged = 0;
	memcpy(head.target, tar.c_str(), 6);
}

/**
* Reads from a socket the appropriate number of bytes and puts it into a new object.
* If the message type is unknown (or payload is empty), returns a regular Header.
* TODO socket will be non-blocking, so if there is no data, then "type" will be 0.
*/
Header * Header::deserialize(int sockfd) {
	
	// set up data structures
	char buffer[100];
	memset(buffer, 0, sizeof(buffer));

	struct sockaddr_in sender;
	socklen_t senderSize = sizeof(sender);
	socklen_t backup = senderSize;


	// get data from socket
	int ret = recvfrom(sockfd, buffer, sizeof(buffer), 0 ,
		(sockaddr *) &sender, &senderSize);
	if (ret == -1) {
		int val = errno;
		if (val == EAGAIN || val == EWOULDBLOCK) {
			// printf("No data to read.\n");
			Header  * h = new Header();
			h->head.type = 0;
			return h;
		}
		printf("Error reading from socket: %d, %s\n", val, strerror(val) );
	}


	// sender diagnostics, mainly for fun
	if (backup != senderSize) {
		printf("The sender address of this message changed (%d -> %d)\n", backup, senderSize);
	}
	// printf("sin_family: %hd\t", sender.sin_family);
	// printf("AF_INET := %d\n", AF_INET);
	char ip_buffer[100];
	memset(ip_buffer, 0, sizeof(ip_buffer));
	inet_ntop(AF_INET, &sender.sin_addr.s_addr, ip_buffer, sizeof(ip_buffer));
	printf("Sending address: %s:%hu\n", ip_buffer, ntohs(sender.sin_port));


	// validate the input some
	if (ret > sizeof(buffer)) {
		printf("Read too many bytes for buffer, truncating message.\n");
		ret = sizeof(buffer);
	}
	if (ret < sizeof(Header::head)) {
		printf("Not enough bytes to fill a Header object.\n");
	}

	// make and return new object
	Header * h = new Header(buffer);
	if (h->head.protocol != 1024) {
		printf("Incorrect protocol number, probably bad packet.\n");
	}
	// printf("Size: %d\nProtocol: %d\nType: %d\n", h.size, h.protocol, h.type);
	// h.printEverything();


	map<int, Header *(*)(char *)>::iterator it = typeToCon.find(h->head.type);
	if (it == typeToCon.end()) {
		printf("No constructor found for message type: %d\n", h->head.type);
		return h;
	}

	h = (it->second)(buffer);

	return h;
}

MessageBuffer * Header::makeBuffer() {
	char buf[sizeof(Header::head)];
	int size = sizeof(head);
	memcpy(buf, &head, sizeof(head));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void Header::printEverything() {
	cout << "~~~~~~~ Frame ~~~~~~~" << endl;
	cout << fcol << "size" << tab << head.size << endl;
	cout << fcol << "protocol" << tab << head.protocol << endl;
	cout << fcol << "addressable" << tab << bitset<1>(head.addressable) << endl;
	cout << fcol << "tagged" << tab << bitset<1>(head.tagged) << endl;
	cout << fcol << "origin" << tab << bitset<2>(head.origin) << endl;
	cout << fcol << "source" << tab << head.source << endl;
	cout << "~~~~~ Frame Address ~~~~~" << endl;
	cout << fcol << "target" << tab << "0x" << flush;
	char buf[8];
	memcpy(buf, &(head.target), 8);
	for (int i = 0; i < 8; i++) {
		printf("%2hhx", buf[i]);
	}
	printf("\n");
	cout << fcol << "reserved" << tab << "6 bytes" << endl;
	cout << fcol << "res_required" << tab << bitset<1>(head.res_required) << endl;
	cout << fcol << "ack_required" << tab << bitset<1>(head.ack_required) << endl;
	cout << fcol << "reserved" << tab << "6 bits" << endl;
	cout << fcol << "sequence" << tab << bitset<8>(head.sequence).to_ulong() << endl;
	cout << "~~~~~ Protocol Header ~~~~~" << endl;
	cout << fcol << "reserved" << tab << "8 bytes" << endl;
	cout << fcol << "type" << tab << head.type << endl;
	cout << fcol << "reserved" << tab << "2 bytes" << endl;
}

GetService::GetService() {
	head.type = 2;
}

GetService::GetService(char * buf) : Header(buf) {
}

GetService * GetServiceFac(char * buf){
	return new GetService(buf);
}


StateService::StateService(uint8_t _service, uint32_t _port) {
	head.type = 3;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.service = _service;
	payload.port = _port;
}

StateService::StateService(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateService::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateService::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "service" << tab << payload.service << endl;
	cout << fcol << "port" << tab << payload.port << endl;
}

StateService * StateServiceFac(char * buf){
	return new StateService(buf);
}


GetHostInfo::GetHostInfo() {
	head.type = 2;
}

GetHostInfo::GetHostInfo(char * buf) : Header(buf) {
}

GetHostInfo * GetHostInfoFac(char * buf){
	return new GetHostInfo(buf);
}


StateHostInfo::StateHostInfo(float _signal, uint32_t _tx, uint32_t _rx) {
	head.type = 3;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.signal = _signal;
	payload.tx = _tx;
	payload.rx = _rx;
}

StateHostInfo::StateHostInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateHostInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateHostInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "signal" << tab << payload.signal << endl;
	cout << fcol << "tx" << tab << payload.tx << endl;
	cout << fcol << "rx" << tab << payload.rx << endl;
	cout << fcol << "reserved" << tab << "16+ bits" << endl;
}

StateHostInfo * StateHostInfoFac(char * buf){
	return new StateHostInfo(buf);
}


GetHostFirmware::GetHostFirmware() {
	head.type = 4;
}

GetHostFirmware::GetHostFirmware(char * buf) : Header(buf) {
}

GetHostFirmware * GetHostFirmwareFac(char * buf){
	return new GetHostFirmware(buf);
}


StateHostFirmware::StateHostFirmware(uint64_t _build, uint32_t _version) {
	head.type = 5;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.build = _build;
	payload.version = _version;
}

StateHostFirmware::StateHostFirmware(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateHostFirmware::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateHostFirmware::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "build" << tab << payload.build << endl;
	cout << fcol << "reserved" << tab << "64 bits" << endl;
	cout << fcol << "version" << tab << payload.version << endl;
}

StateHostFirmware * StateHostFirmwareFac(char * buf){
	return new StateHostFirmware(buf);
}


GetWifiInfo::GetWifiInfo() {
	head.type = 16;
}

GetWifiInfo::GetWifiInfo(char * buf) : Header(buf) {
}

GetWifiInfo * GetWifiInfoFac(char * buf){
	return new GetWifiInfo(buf);
}


StateWifiInfo::StateWifiInfo(float _signal, uint32_t _tx, uint32_t _rx) {
	head.type = 17;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.signal = _signal;
	payload.tx = _tx;
	payload.rx = _rx;
}

StateWifiInfo::StateWifiInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateWifiInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateWifiInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "signal" << tab << payload.signal << endl;
	cout << fcol << "tx" << tab << payload.tx << endl;
	cout << fcol << "rx" << tab << payload.rx << endl;
	cout << fcol << "reserved" << tab << "16+ bits" << endl;
}

StateWifiInfo * StateWifiInfoFac(char * buf){
	return new StateWifiInfo(buf);
}


GetWifiFirmware::GetWifiFirmware() {
	head.type = 18;
}

GetWifiFirmware::GetWifiFirmware(char * buf) : Header(buf) {
}

GetWifiFirmware * GetWifiFirmwareFac(char * buf){
	return new GetWifiFirmware(buf);
}


StateWifiFirmware::StateWifiFirmware(uint64_t _build, uint32_t _version) {
	head.type = 19;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.build = _build;
	payload.version = _version;
}

StateWifiFirmware::StateWifiFirmware(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateWifiFirmware::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateWifiFirmware::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "build" << tab << payload.build << endl;
	cout << fcol << "reserved" << tab << "64 bits" << endl;
	cout << fcol << "version" << tab << payload.version << endl;
}

StateWifiFirmware * StateWifiFirmwareFac(char * buf){
	return new StateWifiFirmware(buf);
}


GetPower::GetPower() {
	head.type = 20;
}

GetPower::GetPower(char * buf) : Header(buf) {
}

GetPower * GetPowerFac(char * buf){
	return new GetPower(buf);
}


SetPower::SetPower(uint16_t _level) {
	head.type = 21;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
}

SetPower::SetPower(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetPower::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetPower::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
}

SetPower * SetPowerFac(char * buf){
	return new SetPower(buf);
}


StatePower::StatePower(uint16_t _level) {
	head.type = 22;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
}

StatePower::StatePower(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StatePower::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StatePower::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
}

StatePower * StatePowerFac(char * buf){
	return new StatePower(buf);
}


GetLabel::GetLabel() {
	head.type = 23;
}

GetLabel::GetLabel(char * buf) : Header(buf) {
}

GetLabel * GetLabelFac(char * buf){
	return new GetLabel(buf);
}


SetLabel::SetLabel(string _payload) {
	head.type = 24;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

SetLabel::SetLabel(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetLabel::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetLabel::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[32]" << tab << payload.payload[32] << endl;
}

SetLabel * SetLabelFac(char * buf){
	return new SetLabel(buf);
}


StateLabel::StateLabel(string _payload) {
	head.type = 25;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

StateLabel::StateLabel(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateLabel::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateLabel::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[32]" << tab << payload.payload[32] << endl;
}

StateLabel * StateLabelFac(char * buf){
	return new StateLabel(buf);
}


GetVersion::GetVersion() {
	head.type = 32;
}

GetVersion::GetVersion(char * buf) : Header(buf) {
}

GetVersion * GetVersionFac(char * buf){
	return new GetVersion(buf);
}


StateVersion::StateVersion(uint32_t _vendor, uint32_t _product, uint32_t _version) {
	head.type = 33;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.vendor = _vendor;
	payload.product = _product;
	payload.version = _version;
}

StateVersion::StateVersion(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateVersion::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateVersion::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "vendor" << tab << payload.vendor << endl;
	cout << fcol << "product" << tab << payload.product << endl;
	cout << fcol << "version" << tab << payload.version << endl;
}

StateVersion * StateVersionFac(char * buf){
	return new StateVersion(buf);
}


GetInfo::GetInfo() {
	head.type = 34;
}

GetInfo::GetInfo(char * buf) : Header(buf) {
}

GetInfo * GetInfoFac(char * buf){
	return new GetInfo(buf);
}


StateInfo::StateInfo(uint64_t _time, uint64_t _uptime, uint64_t _downtime) {
	head.type = 35;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.time = _time;
	payload.uptime = _uptime;
	payload.downtime = _downtime;
}

StateInfo::StateInfo(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateInfo::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateInfo::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "time" << tab << payload.time << endl;
	cout << fcol << "uptime" << tab << payload.uptime << endl;
	cout << fcol << "downtime" << tab << payload.downtime << endl;
}

StateInfo * StateInfoFac(char * buf){
	return new StateInfo(buf);
}


Acknowledgement::Acknowledgement() {
	head.type = 45;
}

Acknowledgement::Acknowledgement(char * buf) : Header(buf) {
}

Acknowledgement * AcknowledgementFac(char * buf){
	return new Acknowledgement(buf);
}


GetLocation::GetLocation() {
	head.type = 48;
}

GetLocation::GetLocation(char * buf) : Header(buf) {
}

GetLocation * GetLocationFac(char * buf){
	return new GetLocation(buf);
}


StateLocation::StateLocation(string _location, string _label, uint64_t _updated_at) {
	head.type = 50;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.location, _location.c_str(), _location.size());
	memcpy(&payload.label, _label.c_str(), _label.size());
	payload.updated_at = _updated_at;
}

StateLocation::StateLocation(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateLocation::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateLocation::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "location[16]" << tab << payload.location[16] << endl;
	cout << fcol << "label[32]" << tab << payload.label[32] << endl;
	cout << fcol << "updated_at" << tab << payload.updated_at << endl;
}

StateLocation * StateLocationFac(char * buf){
	return new StateLocation(buf);
}


GetGroup::GetGroup() {
	head.type = 51;
}

GetGroup::GetGroup(char * buf) : Header(buf) {
}

GetGroup * GetGroupFac(char * buf){
	return new GetGroup(buf);
}


StateGroup::StateGroup(string _location, string _label, uint64_t _updated_at) {
	head.type = 53;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.location, _location.c_str(), _location.size());
	memcpy(&payload.label, _label.c_str(), _label.size());
	payload.updated_at = _updated_at;
}

StateGroup::StateGroup(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StateGroup::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StateGroup::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "location[16]" << tab << payload.location[16] << endl;
	cout << fcol << "label[32]" << tab << payload.label[32] << endl;
	cout << fcol << "updated_at" << tab << payload.updated_at << endl;
}

StateGroup * StateGroupFac(char * buf){
	return new StateGroup(buf);
}


EchoRequest::EchoRequest(string _payload) {
	head.type = 58;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

EchoRequest::EchoRequest(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * EchoRequest::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void EchoRequest::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[64]" << tab << payload.payload[64] << endl;
}

EchoRequest * EchoRequestFac(char * buf){
	return new EchoRequest(buf);
}


EchoResponse::EchoResponse(string _payload) {
	head.type = 59;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	memcpy(&payload.payload, _payload.c_str(), _payload.size());
}

EchoResponse::EchoResponse(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * EchoResponse::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void EchoResponse::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "payload[64]" << tab << payload.payload[64] << endl;
}

EchoResponse * EchoResponseFac(char * buf){
	return new EchoResponse(buf);
}


Get::Get() {
	head.type = 101;
}

Get::Get(char * buf) : Header(buf) {
}

Get * GetFac(char * buf){
	return new Get(buf);
}


SetColor::SetColor(uint16_t _hue, uint16_t _saturation, uint16_t _brightness, uint16_t _kelvin, uint32_t _duration) {
	head.type = 102;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.hue = _hue;
	payload.saturation = _saturation;
	payload.brightness = _brightness;
	payload.kelvin = _kelvin;
	payload.duration = _duration;
}

SetColor::SetColor(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetColor::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetColor::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "reserved" << tab << "8 bits" << endl;
	cout << fcol << "hue" << tab << payload.hue << endl;
	cout << fcol << "saturation" << tab << payload.saturation << endl;
	cout << fcol << "brightness" << tab << payload.brightness << endl;
	cout << fcol << "kelvin" << tab << payload.kelvin << endl;
	cout << fcol << "duration" << tab << payload.duration << endl;
}

SetColor * SetColorFac(char * buf){
	return new SetColor(buf);
}


State::State(uint16_t _hue, uint16_t _saturation, uint16_t _brightness, uint16_t _kelvin, uint16_t _power, string _label) {
	head.type = 107;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.hue = _hue;
	payload.saturation = _saturation;
	payload.brightness = _brightness;
	payload.kelvin = _kelvin;
	payload.power = _power;
	memcpy(&payload.label, _label.c_str(), _label.size());
}

State::State(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * State::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void State::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "hue" << tab << payload.hue << endl;
	cout << fcol << "saturation" << tab << payload.saturation << endl;
	cout << fcol << "brightness" << tab << payload.brightness << endl;
	cout << fcol << "kelvin" << tab << payload.kelvin << endl;
	cout << fcol << "reserved" << tab << "16+ bits" << endl;
	cout << fcol << "power" << tab << payload.power << endl;
	cout << fcol << "label[32]" << tab << payload.label[32] << endl;
	cout << fcol << "reserved" << tab << "64 bits" << endl;
}

State * StateFac(char * buf){
	return new State(buf);
}


GetPower_Light::GetPower_Light() {
	head.type = 116;
}

GetPower_Light::GetPower_Light(char * buf) : Header(buf) {
}

GetPower_Light * GetPower_LightFac(char * buf){
	return new GetPower_Light(buf);
}


SetPower_Light::SetPower_Light(uint16_t _level, uint32_t _duration) {
	head.type = 117;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
	payload.duration = _duration;
}

SetPower_Light::SetPower_Light(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * SetPower_Light::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void SetPower_Light::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
	cout << fcol << "duration" << tab << payload.duration << endl;
}

SetPower_Light * SetPower_LightFac(char * buf){
	return new SetPower_Light(buf);
}


StatePower_Light::StatePower_Light(uint16_t _level) {
	head.type = 118;
	head.size = sizeof(head) + sizeof(payload);
	memset(&payload, 0, sizeof(payload));
	payload.level = _level;
}

StatePower_Light::StatePower_Light(char * buf) : Header(buf) {
	memcpy(&payload, buf + sizeof(head), sizeof(payload));
}

MessageBuffer * StatePower_Light::makeBuffer() {
	char buf[ sizeof(head) + sizeof(payload)];
	int size = sizeof(head) + sizeof(payload);
	memcpy(buf, &head, sizeof(head));
	memcpy(buf + sizeof(head), &payload, sizeof(payload));
	MessageBuffer * mb = new MessageBuffer(buf, size);
	return mb;
}

void StatePower_Light::printEverything() {
	Header::printEverything();
	cout << "~~~~~~ Payload ~~~~~~" << endl;
	cout << fcol << "level" << tab << payload.level << endl;
}

StatePower_Light * StatePower_LightFac(char * buf){
	return new StatePower_Light(buf);
}


